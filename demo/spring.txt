서버단 작성
1) spring framework : 웹 개발할때 주로 사용 / 설정 작업 필요 / 
2) spring boot : spring framework 간편화버전

프로젝트 생성
1. 빌드 툴 설정
build : 프로젝트 생성, 라이브러리 설정, 코드작업, 컴파일, 테스트, 패키기작성, 배포
ㄴ1). gradle : text 기반, <<후발 (≒maver의 개선판)
ㄴ2). maven : xml 기반,

2.spring boot version 선택 : 3.4.4
3.언어 선택
4.패키지명 : con.example.demo (자유롭게 지정 가능)
5.패키징타입 : jar(java압축파일), war(자바 웹 압축파일-jsp)
6.자바버전선택: 부트버전에 따라 선택이 달라질 수 있음
7,필요라이브러리 선택:
8.Spring Web,dev tools,thymeleaf,lombok, spring data jpa, oracle driver,validation
, thymleaf dialect
화면(front)단 작성 : html + css + javascript + java
1)jsp 활용 : *.jsp 
    html 코드 + java 코드 동시작성
    spring boot 에서 사용하기 위해서는 설정작업 필요

2) 템플릿 엔진 활용 : *.html
    thymeleaf, mustache, groovy, freemakerm velocity...


스프링 주요 개념

1) IoC (Inversion of Control) : 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라 외부(spring container)에서 결정 (제어의 역전)
    class A {}
    class B {
        A obj = new A();
    }
    
    컨테이너는 어느 객체를 생성할 것인지 알아야 함 => 어노테이션으로 알려주기
    -컨테이너가 생성한 객체 : Bean
    -싱글톤 방식 (객체는 하나만 생성) 으로 객체 생성
    -@Controller, @Service, @Component

2)경로 임의로 생성
http://localhost:8080/ ==> Controller 파일의 메소드와 매핑

uri 설계
ex)게시판 개발

게시글 작성 : /borad/create
게시글 목록 : /borad/list
게시글 조회 : /borad/read
게시글 수정 : /borad/update

@GetMapping("/create")
public String method(){
    return "info";
}

http://localhost:8080/board/create 브라우저에서 요청 => 컨트롤러 응답 => templates 찾기 (templates / return 값 찾기)
=> templates / info.html 작성

@GetMapping("/update")
public void method(){

}

http://localhost:8080/board/update 브라우저에서 요청 => 컨트롤러 응답 => templates 찾기 (templates / board/update)
=> templates / board / update.html 작성

3) 내장 서버 : Tomcat(설치 후 사용 - 스프링부트를 사용한다면 내장되어 있음)

http://localhost:8080/: Tomcat 서버 구동 시 기본경로

브라우저를 통해 http, https 프로토콜에 응답하는 서버 : SW 웹 서버(Apache, NginX)
WAS(Web Application Server) : 웹서버 + 자바해석 => Tomcat

4) 오류발생

    400 : bad request 잘못된 입력
    404 : 컨트롤러 경로확인
    405 : 컨트롤러 경로 + 매핑방식 확인

5) 사용자 입력값 가져오기
    (1) 변수 이용 : 타입지정가능, 변수명은 form 요소의 이름과 일치
    (2) 커맨드(DTO) 객체 이용 : 타입지정가능, 변수명은 form 요소의 이름과 일치
                                커맨드 객체 사용시 장점은 template 페이지까지 입력값이 유지됨
    (3) HttpServletRequest 이용 : 사용자의 정보를 가져와 입력값 추출

6) @ModelAttribute
    - 별칭
    - model.addAttribute("num1", num1) == @ModelAttribute("num1) : template 페이지에서 값을 유지하고 싶다면
7) RedirectAttributes : 컨트롤러에서 움직이는 방식이 Redirect일때 사용 움직이면서 특정값을 가지고 싶을때 사용
rttr.addAtribute("userid",10); ?userid=10 => 템플릿 ${param.userid}
rttr.addFlashAttribute("password", "12"); session 객체에 담는것과 같은 방식 템플릿 ${password}

8) 데이터 유지하기
 - login.html 입력값 ==> 컨트롤러 ==> logout.html 입력값 유지를 하고싶다면
    - forward 방식 : @modelAttribute, Model, 커맨드객체
    - redirect 방식 : RedirectAttributes 이용
 - login.html 입력값 ==> 컨트롤러 ==> 모든페이지에서 입력값 유지를 하고싶다면
    - 세션 : 값을 서버쪽에 저장 (객체형태로 담는 것 가능)
        HttpSession 을 이용해 저장 => 필요없는경우 제거 or 현재 세션이 유지되고 있는 브라우저를 닫으면 종료됨
    - 쿠키 : 값을 클라이언트 브라우저로 전송 후 저장
 - login.html 입력값 ==> 컨트롤러 ==> 다른페이지에서는 입력값 소멸?
    - 컨트롤러에서 변수로 받아오는 경우
 
 경로 설정
 http://localhost8080/ 고정
 href 경로 설정 시 현재경로 (주소줄에 있는 경로)

 th:href="@{ex1(id=${dto.id})}" : 현재 경로에서 맨 마지막 가장 마지막 경로를 대체하여 주소설정
 th:href="@{/ex1(id=${dto.id})}" : http://localhost8080 다음부터 경로 설정

 현재경로 http://localhost:8080/sample
 href
 움직일경로  http://localhost:8080/ex1


데이터베이스 작업 => 프레임워크
1. MyBatis
2. JPA : 객체 == 테이블
    JPA 기술을 구현한 Hibernate 구현체가 존재

    spring.jpa.hibernate.ddl-auto=5가지 종류
    1)create : 기존 테이블 삭제 후 테이블 생성 (개발 시)
    2)create-drop : 기존테이블 삭제 후 테이블 생성, 종료시점에 테이블 삭제 (개발 시)
    3)update : 변경된 부분만 적용 (개발 시)
    4)validate : 엔티티와 테이블 정상매핑 확인 (스테이징, 운영환경)
    5)none : 사용하지 않음 (스테이징, 운영환경)

-------------------------------------------------------------------------------
Oracle인 경우

    Entity명이 테이블 명으로 사용됨(기본)
    @Table(name = "studenttbl") : Entity 명이 아닌 지정된 이름으로 테이블 생성
    @GeneratedValue
    @GeneratedValue == @GeneratedValue(strategy = GenerationType.AUTO)

    - create sequence studenttbl_seq start with 1 increment by 50

---------------------------------------------------------------------------------------------------

    @GeneratedValue(strategy = GenerationType.IDENTITY)
        -id number(19,0) generated by default as identity,



    @SequenceGenerator(name = "student_seq_gen", sequenceName = "student_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "student_seq_gen")
        -create sequence student_seq start with 1 increment by 1
    
